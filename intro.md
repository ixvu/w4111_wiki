# Introduction to W4111

*(This is an example sketch of scribe notes for lecture 1.  Start with a paragraph summary of the topic, along with a bullet list of the main sub-topics. )*

The goal of this class is two-fold.  First, to introduce you to core database concepts (e.g., data modeling, logical design, SQL) so that you too can build a billion dollar application.  Second, to teach enough about database engine internals (e.g., physical database design, query optimization,     transaction processing) so you have a good sense of why queries may be running slowly/incorrectly.

The lecture goes over four ideas

* Why data is popular
* What application areas is data used in
* What is data and a database?
* What does this course cover?
* A short overview of a database system and its components.


## Why Data is Popular?

Data's popularity is based on two factors: the ability to generate data, and the ability to store data cheaply.

Storing data was historically expensive because it required manual work in order to write, chisel, carve data into physical objects.  The computer era drove down data storage costs exponentially--a one terabyte drive costs less than a nice dinner today.  

Generating data was historically expensive because of manual work.  Even today, the vast majority of data (by volume) is not generated by humans.  Back of the envelope calculation shows that number of credit card transactions per day is XXX and the volume of tweets per day is YYY.  If every human were to type continuously, it would only generate ZZZ per day. Thus data is primarily generated automatically.

*...*

## What is a Database System?
* What’s a database?
    * A very large, integrated collection of data
* Usually a model of a real-world enterprise
    * Entities (e.g., students, courses, Facebook users, ...) with attributes (e.g., name, birthdate, GPA, ...)
    * Relationships (e.g., Susan is taking CS 234, Susan is a friend of Lynn, ...)
* What’s a database management system (DBMS)?
    * A software system designed to store, manage, and provide access to one or more databases
    * More specifically, system to safely and reliably store lots of persistent structured data that is convenient for multiple users to efficiently access and modify.

## File Systems vs. DBMS
* Application programs must sometimes stage large datasets between main memory and secondary storage (for buffering huge data sets, getting page-oriented access, etc.)
* Special code needed for different queries, and that code must be (stay) correct and efficient
* Must protect data from inconsistency due to multiple concurrent users
* Crash recovery is important since data is now the currency of the day (corporate jewels)
* Security and access control are also important(!)

## Why Use a DBMS?
Two key concepts:
* Data independence (Levels of abstraction give data independence)
* Declarative Languages 

More:
* Efficient data access (Fast:100k+queries/sec)
* Reduced application development time
* Data integrity and security
* Uniform data administration
* Concurrent access, recovery from crashes

## Why Study Databases?
* DBMS field encompasses most of CS
    * OS: DBMS directly manages hardware
    * Language: SQL is a domain specific language
    * Theory: Algorithms, models, NP-complete
    * AI/ML: Knowledge Discovery
    * Logic: RelationalAlgebra = 1st order logic
* Datasets increasing in diversity and volume (videos, webs...etc)

## DBMSes in the Wild
* Classic Relational
    * Oracle, IBM, Microsoft, Teradata, EMC, etc Free: MySQL, PostgreSQL, SQLite
* New Relational
    * In-Memory, Column-store, Streaming
* Non-traditional
    * Search (Google, Bing, Lucene), Scientific, Geographic
* NoSQL
    * Big Data: Hadoop, Spark, etc
    * Key-value: Mongo, BerkeleyDB, Cassandra, etc
* DBMS-as-a-Service
    * Microsoft Azure, Amazon Redshift/RDS, etc...

## What does this course cover?
* Intro to DBMSes
* Data Models (Entity-relation, Relational, ...)
* Relational Algebra
* SQL
* Applications + SQL (cursors, APIs, embedded ...)
* Normalization
* Peek at DBMS internals:
    * Storage and indexing
    * Query optimization
    * Transaction Processing
    * Recovery